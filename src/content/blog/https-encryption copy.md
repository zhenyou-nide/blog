---
author: zhenyounide
pubDatetime: 2024-08-06T04:06:31Z
title: Https 加密通信过程
slug: https-encryption-draft
featured: false
draft: true
tags:
  - summary
description: ""
---

## Table of contents

## HTTP 为什么不安全

HTTP 由于是明文传输，主要存在三大风险

1. 窃听风险: 中间人可以获取到通信内容

2. 篡改风险: 中间人可以篡改报文内容后再发送给对方

3. 冒充风险: 比如你以为是在和某宝通信，但实际上是在和一个钓鱼网站通信。

HTTPS 显然是为了解决这三大风险而存在的，接下来我们看看 HTTPS 到底解决了什么问题。

## 原理

### 对称加密： HTTPS 的最终加密形式

既然 HTTP 是明文传输的，那我们给报文加密不就行了，既然要加密，我们肯定需要通信双方协商好密钥吧，一种是通信双方使用**同一把密钥**，即**对称加密**的方式来给报文进行加解密。

![img](https://camo.githubusercontent.com/4817127c047a9eebfdb2f1c22fb43dce42df2f62a4d06b1c40d715a0b0935f4a/68747470733a2f2f70332d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f30313466616537383837373634376339613666376231663030326636666339317e74706c762d6b3375316662706663702d7a6f6f6d2d312e696d616765)

如图示：使用对称加密的通信双方使用**同一把**密钥进行加解密。

对称加密具有加解密速度快，性能高的特点，也是 HTTPS 最终采用的加密形式，但是这里有一个关键问题，对称加密的通信双方要使用同一把密钥，这个密钥是如何协商出来的？如果通过报文的方式直接传输密钥，之后的通信其实还是在裸奔，因为这个密钥会被中间人截获甚至替换掉，这样中间人就可以用截获的密钥解密报文，甚至替换掉密钥以达到篡改报文的目的。

![img](https://camo.githubusercontent.com/853fad67ede0f47039c0a17daaff0699a396ceedfacac3c6f215fd6acf544c7d/68747470733a2f2f70332d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f66356433663636623339656534343563623061306563353164346165363839397e74706c762d6b3375316662706663702d7a6f6f6d2d312e696d616765)

有人说对这个密钥加密不就完了，但对方如果要解密这个密钥还是要传加密密钥给对方，依然还是会被中间人截获的，这么看来直接传输密钥无论怎样都无法摆脱俄罗斯套娃的难题，是不可行的。

### 非对称加密：解决单向对称密钥的传输问题

直接传输密钥无论从哪一端传从上节分析来看是不行了，这里我们再看另一种加密方式：**非对称加密**。

非对称加密即加解密双方使用不同的密钥，一把作为公钥，可以公开的，一把作为私钥，不能公开，公钥加密的密文只有私钥可以解密，私钥加密的内容，也只有公钥可以解密。

**注：私钥加密其实这个说法其实并不严谨，准确的说私钥加密应该叫私钥签名，因为私密加密的信息公钥是可以解密的，而公钥是公开的，任何人都可以拿到，用公钥解密叫做验签**

这样的话对于 server 来说，保管好私钥，发布公钥给其他 client, 其他 client 只要把对称加密的密钥加密传给 server 即可，如此一来由于公钥加密只有私钥能解密，而私钥只有 server 有，所以能保证 client 向 server 传输是安全的，server 解密后即可拿到对称加密密钥，这样交换了密钥之后就可以用对称加密密钥通信了。

![img](https://camo.githubusercontent.com/f7720f47684f22e13d66e4ccd62d32b32f181242fc27e9c16fd3a2fbff0fe847/68747470733a2f2f70332d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f62393334353762326664663134396337396432386637393734323239323666667e74706c762d6b3375316662706663702d7a6f6f6d2d312e696d616765)

但是问题又来了， server 怎么把公钥**安全地**传输给 client 呢。如果直接传公钥，也会存在被中间人调包的风险。

![img](https://camo.githubusercontent.com/d0f9ae5b7e0182137ce16d97f1028b5c67cabcb45492953edfe1b5fb625518fa/68747470733a2f2f70332d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f66326137363736613230383034383133626231363837653862346262343735357e74706c762d6b3375316662706663702d7a6f6f6d2d312e696d616765)

### 数字证书，解决公钥传输信任问题

如何解决公钥传输问题呢，从现实生活中的场景找答案，员工入职时，企业一般会要求提供学历证明，显然不是什么阿猫阿狗的本本都可称为学历，这个学历必须由**第三方权威机构（Certificate Authority，简称 CA）**即教育部颁发，同理，server 也可以向 CA 申请证书，**在证书中附上公钥**，然后将证书传给 client，证书由站点管理者向 CA 申请，申请的时候会提交 DNS 主机名等信息，CA 会根据这些信息生成证书

![img](https://camo.githubusercontent.com/35c4d6bbbeae8f9a7ec514cb350f889336836f9471957c6bac3552a673c554e0/68747470733a2f2f70332d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f38363461633132623662663034386131613231343965333663643735333364647e74706c762d6b3375316662706663702d7a6f6f6d2d312e696d616765)

这样当 client 拿到证书后，就可以获得证书上的公钥，再用此公钥加密**对称加密密钥**传给 server 即可，看起来确实很完美，不过在这里大家要考虑两个问题

**问题一、 如何验证证书的真实性，如何防止证书被篡改**

想象一下上文中我们提到的学历，企业如何认定你提供的学历证书是真是假呢，答案是用学历编号，企业拿到证书后用学历编号在学信网上一查就知道证书真伪了，学历编号其实就是我们常说的**数字签名**，可以防止证书造假。

回到 HTTPS 上，证书的数字签名该如何产生的呢，一图胜千言

![img](https://camo.githubusercontent.com/62abe5af60c65a4fb14eda52fd8a4202a8a30dca179f0f47d4fdb1967e855c39/68747470733a2f2f70332d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f30323636336238346431623534616439626365343363343761663231643937357e74706c762d6b3375316662706663702d7a6f6f6d2d312e696d616765)

步骤如下
1、 首先使用一些摘要算法（如 MD5）将证书明文（如证书序列号，DNS主机名等）生成摘要，然后再用第三方权威机构的私钥对生成的摘要进行加密（签名）

> 消息摘要是把任意长度的输入揉和而产生长度固定的伪随机输入的算法，无论输入的消息有多长，计算出来的消息摘要的长度总是固定的，一般来说，只要内容不同，产生的摘要必然不同（相同的概率可以认为接近于 0），所以可以验证内容是否被篡改了。

为啥要先生成摘要再加密呢，不能直接加密？

因为使用非对称加密是非常耗时的，如果把整个证书内容都加密生成签名的话，客户端验验签也需要把签名解密，证书明文较长，客户端验签就需要很长的时间，而用摘要的话，会把内容很长的明文压缩成小得多的定长字符串，客户端验签的话就会快得多。

2、客户端拿到证书后也用同样的摘要算法对证书明文计算摘要，两者一笔对就可以发现报文是否被篡改了，那为啥要用第三方权威机构（Certificate Authority，简称 CA）私钥对摘要加密呢，因为摘要算法是公开的，中间人可以替换掉证书明文，再根据证书上的摘要算法计算出摘要后把证书上的摘要也给替换掉！这样 client 拿到证书后计算摘要发现一样，误以为此证书是合法就中招了。所以必须要用 CA 的私钥给摘要进行加密生成签名，这样的话 client 得用 CA 的公钥来给签名解密，拿到的才是未经篡改合法的摘要（私钥签名，公钥才能解密）

server 将证书传给 client 后，client 的验签过程如下

![img](https://camo.githubusercontent.com/2bad9a96ce778c68dcb9406a1356fe2c61aa434a49493f111e3027627198609c/68747470733a2f2f70332d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f34333564653037396335656134636565383038303138386231363034383939657e74706c762d6b3375316662706663702d7a6f6f6d2d312e696d616765)

这样的话，由于只有 CA 的公钥才能解密签名，如果客户端收到一个假的证书，使用 CA 的公钥是无法解密的，如果客户端收到了真的证书，但证书上的内容被篡改了，摘要比对不成功的话，客户端也会认定此证书非法。

细心的你一定发现了问题，CA 公钥如何安全地传输到 client ？如果还是从 server 传输到 client，依然无法解决公钥被调包的风险，**实际上此公钥是存在于 CA 证书上，而此证书（也称 Root CA 证书）被操作系统信任，内置在操作系统上的，无需传输**，如果用的是 Mac 的同学，可以打开 keychain 查看一下，可以看到很多内置的被信任的证书。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/000d3f8ba74240c79d20cfd19aa4d509~tplv-k3u1fbpfcp-zoom-1.image)

server 传输 CA 颁发的证书，客户中收到证书后使用**内置 CA 证书中的公钥**来解密签名，验签即可，这样的话就解决了公钥传输过程中被调包的风险。

**问题二、 如何防止证书被调包**

实际上任何站点都可以向第三方权威机构申请证书，中间人也不例外。

![img](https://camo.githubusercontent.com/04d51c0553c07608de0e1c85b92ea17fa44983c54e05d6bd6d262cc78107bb1f/68747470733a2f2f70332d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f30303064336638626137343234306337396432306366643139616134643530397e74706c762d6b3375316662706663702d7a6f6f6d2d312e696d616765)

正常站点和中间人都可以向 CA 申请证书，获得认证的证书由于都是 CA 颁发的，所以都是合法的，那么此时中间人是否可以在传输过程中将正常站点发给 client 的证书替换成自己的证书呢，如下所示

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c5e25a281924ba0bbdcb3efa41bbce2~tplv-k3u1fbpfcp-zoom-1.image)

答案是不行，因为客户端除了通过验签的方式验证证书是否合法之外，**还需要验证证书上的域名与自己的请求域名是否一致**，中间人中途虽然可以替换自己向 CA 申请的合法证书，但此证书中的域名与 client 请求的域名不一致，client 会认定为不通过！

但是上面的证书调包给了我们一种思路，什么思路？大家想想， HTTPS 既然是加密的， charles 这些「中间人」为啥能抓到明文的包呢，其实就是用了证书调包这一手法，想想看，在用 charles 抓 HTTPS 的包之前我们先要做什么，当然是安装 charles 的证书

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c07aa643d94414884c9c15687a9fc16~tplv-k3u1fbpfcp-zoom-1.image)

这个证书里有 charles 的公钥，这样的话 charles 就可以将 server 传给 client 的证书调包成自己的证书，client 拿到后就可以用你安装的 charles 证书来验签等，验证通过之后就会用 charles 证书中的公钥来加密对称密钥了，整个流程如下

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6623888038634dbb9c88e05abd0f28ef~tplv-k3u1fbpfcp-zoom-1.image)

由此可知，charles 这些中间人能抓取 HTTPS 包的前提是信任它们的 CA 证书，然后就可以通过替换证书的方式进行瞒天过海，所以我们千万不要随便信任第三方的证书，避免安全风险。
